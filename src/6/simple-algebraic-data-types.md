# 代数的データ型の簡単な例
　積、予積を使って、型を組合せる２つの基本的な方法に触れてきた。その結果、日常のプログラミングの多くのデータ構造はこの２つのメカニズムを使って構築できた。この事実は重要な実践的結論を含んでいる。データ構造の多くのプロパティは合成可能である。例えば、基本型の等価に対する比較をする方法を知り、積型や予積型へこうした比較を一般化する方法を知れば、合成型に対する等価演算の派生を自動化することができる。
プログラミングでよく現れる直積型、直和型について、より詳しく見てみよう。
## 直積型
　プログラミング言語で２つの型の積の標準的な実装はペアである。ペアは狭義な可換ではない。 $(Integer,Boolean)$ のペアは $(Boolean,Integer)$ のペアに置き換えることはできない。たとえ、同じ情報を持つとしても。けれども、同型射の違いを除いて可換である。次のようなswap関数を与えることで同型となる。
$$
swap:(A, B) \rightarrow (B, A)
$$
$$
swap(x, y) = (y, x)
$$
この２つのペアは同じデータを格納する異なる形式を単に使っていると考えることができる。ビッグエンディアンとリトルエンディアンのようなものである。
　ペアの中にペアを入れ子にすることによって任意の数の型から積を合成することができる。しかし、より簡単な方法があり、入れ子のペアはタプルと同値である。それは、異なる方法でネストしたペアは同型であると言う事実の結果である。ある直積の三つの型A,B,Cをこの順序で組み合わせようとすると、次の二通りの方法がある。
$$
((A, B), C)
$$
または
$$
(A, (B, C))
$$
これらの型は異なっている。即ち、一方に対するある関数を他方に適用することはできない。しかし、これらの要素は一対一の対応にある。一方から他方へ写す関数が存在する。
$$
alpha:((A, B), C) \rightarrow (A, (B, C))
$$
$$
alpha((x, y), z) = (x, (y, z))
$$
そして、この関数は可逆である。
$$
alpha\_inv:(A, (B, C)) \rightarrow ((A, B), C)
$$
$$
alpha\_inv(x, (y, z)) = ((x, y), z)
$$
したがって、同型射である。これらはまさに同じデータの再パッケージの異なる方法である。
　直積の創造を型の二項演算として理解することができる。その見方をすると、上記同型射はモノイドで見たような結合法則と非常に似ている。
$$
(a * b) * c = a * (b * c)
$$
それを除けば、モノイドの場合、二つの積の結合は等しいのに、ここでは「同型射の違いを除いて」同値である。
　同型射と共生し、厳密に等価を主張しなければ、さらに$1$が乗法の単位元であることを同じように、単位元、()が直積の単位元であることを更に示すことができる。実際、ある型$A$の値と単位元のペアを作ることは何の情報も追加しない。型
$$
(A, ())
$$
は$A$と同型である。ここで、同型射は
$$
rho:(A, ()) \rightarrow A
$$
$$
rho(x, ()) = x
$$
$$
$$
$$
rho\_inv:A \rightarrow (A, ())
$$
$$
rho\_inv(x) = (x, ())
$$
これらの考察により、${\bf Set}$(集合の圏)は*モノイド圏*と呼ぶことで形式化することができる。それは圏であり、また、対象を掛けることができる（ここでは、デカルト積を取ることができる）と言う意味でモノイドである。例えば、次のように`Pair`を定義する。
```java
class Pair<A,B> {
  final A a;
  final B b;
  Pair(A a, B b) {
    this.a = a;
    this.b = b;
  }
}
```
ここで、`Pair`は二つの異なる型`A`と`B`によって型引数を指定している。コンストラクタ`Pair`は適切な型の二つの値を通じてペア型を定義している。例えば、`String`と`Boolean`のペアとして`stmt`と言う値を定義してみよう。
```java
Pair<String, Boolean> stmt = new Pair<>("This statement is", false);
```
`Pair<String, Boolean> stmt`が宣言である。総称型`Pair`の`A`と`B`を`String`と`Boolean`で置き換えている。`new Pair<>("This statement is", false)`は`A`の具体的な値と`B`の具体的な値を通じて実際の値を定義している。
　総称型のペアを使わず、特定の直積型を定義することもできる。
```java
class Stmt {
  final String a;
  final Boolean b;
  Stmt(String a, Boolean b) {
    this.a = a;
    this.b = b;
  }
}
```
これは`String`と`Boolean`の直積である。このスタイルの宣言の利点は、異なった意味や機能を持つ同じ構成の多くの型を定義でき、それらは互いに置き換えることはできない。
　タプルや複数の引数を持つコンストラクタでのプログラミングは、厄介で間違いを起こしやすく、どのコンポーネントが何を表現しているか絶えず注意を払う必要がある。コンポーネントに名前を与えることがよく好まれている。名前付けされたフィールドを持つ直積型はHaskellではレコードと呼ばれ、Javaではクラスで代替することができる。
