# 積と余積
 古代ギリシャの劇作家エウリピデスは言った。「人はその人が付き合っている人に似ている（類は友を呼ぶ）」我々は関係によって定義されている。そのことがどこよりも明らかなのは圏論である。ある圏からある特別な対象を選択したいなら、他の対象（及びそれ自体）との関係性のパターンを表すだけでよい。このような関係性は射で定義される。
 圏論では普遍的構成と呼ばれる共通の構成があり、対象とそれらの関連性により定義される。これを行う一つの方法はあるパターン、即ち対象と射から構成されるある特定の形を選び取り、その圏のすべての発生を探し求める方法である。それが十分に共通なパターンで、その圏が大きいならば、非常にたくさんの命中を得る公算が高い。これらの命中の間である種のランキングを構築し、何が最適なものを考えられるか選びとるのがコツである。
 この過程はウェブ検索する方法を連想させる。問い合わせはパターンに似ている。かなり一般的な問い合わせは大きな再現率、たくさんの命中を与えるだろう。あるものは関連性があるかもしれないし、別のものはないかもしれない。関連性のないヒットを取り除くため、問い合わせを見直す。それによって精度が増す。最終的に検索エンジンはそのヒットをランク付けし、うまくいけば、最も関心がある一つの結果がリストの最上位にくるだろう。
## 始対象
 最も単純な形は単一の対象である。ある圏を与えると、明らかに対象が存在するのと同じ数だけこの形のインスタンスが存在する。そこから選びとるには手間がかかる。ある種のランク付けを構築して、このヒエラルキーの最上位である対象を見つけようとする必要がある。我々が自由に使えるのは使えるのは射だけである。射を矢印として考えると、圏のある終端から別の終端への矢印のすべてのネットフローが存在することが可能である。順序圏、例えば半順序圏ではこれは成り立つ。対象`a`から対象`b`への矢印（射）が存在すれば、`a`が`b`「より始まりに近い」とすることで対象の優先順位の概念を一般化出来る。すべての自身以外の対象への矢印を持つような対象を始対象と定義する。明らかにこのような対象が存在する保証はない。より大きな問題として、余りにたくさんのこのような対象が存在するかもしれない。適合率はよいが、精度は失われる。その答えは順序圏からヒントを得ることが出来る。即ち、任意の２つの対象の間には高々１つの矢印しかない。別の対象より小さい、または等しいと言う一方向だけが存在する。そこで次のような始対象の定義を導く。
```
**始対象**はその圏の中の任意の対象へ向かう１つ、かつ唯一の射を持つ
```
 けれども（もし存在したとしても）始対象の一意性は保証されていない。しかし、一意性については次の最も良いことが保証されている、即ち一意性が同型次第であると言うことである。同型は圏論では非常に重要であり、まもなく少し触れる。さしあたり、一意性が同型次第であることが始対象の定義で対象を特定することが正当化される。
 ここで例を挙げる。半順序集合（よくposetと呼ばれる）での始対象は最小の要素である。始対象を持たない半順序集合も存在する。例えば、以下の関係を射とする、全ての整数、正数と負数の集合がある。
 集合と関数の圏では、始対象は空集合である。
### 終対象
 単一対象パターンを続けよう。今度は対象のランク付けの方法を変更する。もし対象`b`から対象`a`への射（向きが逆）が存在すれば、`a`が`b`「より終わりに近い」ととする。圏の自身以外の対象より終わりに近い対象を探してみる。再び一意性を主張する。
```
**終対象**はその圏の中の任意の対象から向かってくる１つ、かつ唯一の射を持つ。
```
さらに再び、終対象は同型次第である。これもまもなく触れる。最初に例を見ておこう。半順序集合では、終対象は、もし存在すれば、最大の対象である。集合の圏では、終対象はシングルトンである。既にシングルトンについては触れた。javaではvoidがそれに対応する。それは唯一つの値を持つ型である。javaでは暗黙的にである。任意の型から単位型への唯一つの純粋関数を構築出来る。
```java
Function<A,void> unit = x -> { return; };
```
全ての終対象の条件は満たされている。
 この例で一意性は重要である。なぜなら、任意の集合から向かってくる射を持つ他の集合（実際には、空集合を除く全ての集合）が存在する。例えば、任意の型に対して定義されたブール値関数（述語）が存在する。
```java
Function <A, Boolean> yes = x -> True;
```
 しかし、Booleanは終対象ではない。少なくとももう一つの任意の集合から向かってくる射が存在する。
```java
Function <A, Boolean> no = x -> False;
```
